<!DOCTYPE html>
<html>
<head>
  <title>Monocular AI Drone</title>
  <style>
    body { 
      margin: 0; 
      background-color: #282C34;
      font-family: Arial, sans-serif; 
      color: #FFF; 
      /* Ensure the body has position: relative so our spinner
         can be absolutely positioned in the center of the page */
      position: relative;
      height: 100vh;
    }

    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      width: 200px;
    }
    #controls h2 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #controls p {
      margin: 5px 0;
      font-size: 14px;
    }
    #speed, #position, #camera-position {
      margin-top: 10px;
      font-size: 14px;
    }
    #pitch-info, #yaw-info, #roll-info {
      margin-top: 6px;
      font-size: 14px;
    }

    /* Main control panel on the left */
    #websocket-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #A40808;
    }
    #websocket-controls h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #websocket-controls button {
      width: 100%;
      padding: 6px;
      background: #A40808;
      border: none;
      border-radius: 3px;
      color: #FFF;
      cursor: pointer;
      font-weight: bold;
      margin-top: 5px;
    }
    #websocket-controls button:hover {
      background: #C51919;
    }
    #goalInput {
      width: 96%;
      padding: 6px;
      margin-top: 5px;
      border-radius: 3px;
      border: none;
    }
    #bboxDisplay {
      font-weight: bold;
      color: #FFD700;
    }

    /* Plan & Steps box */
    #plan-steps-container {
      position: absolute;
      bottom: 20px;
      right: 360px; 
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #048A17;
    }
    #plan-steps-container h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #planList {
      margin: 0;
      padding-left: 20px;
      font-size: 14px;
    }
    .completed-step {
      text-decoration: line-through;
      color: #AAA;
    }

    /* History box */
    #history-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #808080;
    }
    #history-container h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #historyContent {
      white-space: pre-wrap; /* preserve newlines */
      max-height: 180px;
      overflow-y: auto; /* scrollable if long */
      font-size: 14px;
      background-color: rgba(255,255,255,0.05);
      padding: 5px;
      border-radius: 5px;
    }

    /* Loading Spinner */
    #spinner {
      display: none; /* hidden by default */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 9999; /* ensure itâ€™s on top of everything */
      width: 64px;
      height: 64px;
      border: 8px solid rgba(255,255,255,0.2);
      border-top: 8px solid #FFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Spinner element (hidden by default) -->
  <div id="spinner"></div>

  <div id="controls">
    <h2>Controls</h2>
    <p>W/S: Increase/Decrease Throttle</p>
    <p>A/D: Yaw Left/Right</p>
    <p>I/K: Pitch Forward/Backward</p>
    <p>J/L: Roll Left/Right</p>
    <p>C: Toggle Drone (3rd person) View</p>
    <p>M: Toggle Bottom View</p>

    <p id="speed">Speed: 0</p>
    <p id="position">Position: (0, 0, 0)</p>
    <p id="camera-position">Camera Position: (0, 0, 0)</p>

    <p id="pitch-info">Pitch: 0</p>
    <p id="yaw-info">Yaw: 0</p>
    <p id="roll-info">Roll: 0</p>
  </div>

  <div id="websocket-controls">
    <h2>AI Pilot</h2>

    <!-- This button calls /get_plan and /generate_history to retrieve a plan and update history. -->
    <button id="retrievePlanBtn">Retrieve Plan</button>
    <label for="goalInput">Goal for Plan:</label>
    <input type="text" id="goalInput" value="Explore the city" />

    <!-- After we have plan, we can open the WS and do bounding boxes. -->
    <button id="openWsBtn">Open WebSocket</button>

    <!-- We'll send the first step or any step to the WS as the "goal" -->
    <button id="sendStepBtn">Send Current Step to WS</button>

    <button id="sendFrameBtn">Send Frame (WS)</button>
    <button id="nextStepBtn">Complete Current Step</button>

    <p>Bounding Box: <span id="bboxDisplay">N/A</span></p>
  </div>

  <div id="plan-steps-container">
    <h2>Plan & Steps</h2>
    <ol id="planList"></ol>
  </div>

  <div id="history-container">
    <h2>History</h2>
    <div id="historyContent">No history yet.</div>
  </div>

  <!-- Drone-related scripts (assume your simulation code) -->
  <script src="https://threejs.org/build/three.js"></script>
  <script type="module" src="drone.js"></script>

  <script>
    let ws = null;
    let planSteps = [];
    let currentStepIndex = 0;
    let currentGoalText = ""; 
    // Will store the history array from the backend
    let globalHistory = null;

    // Helper function to show/hide the spinner
    function showSpinner() {
      document.getElementById('spinner').style.display = 'block';
    }
    function hideSpinner() {
      document.getElementById('spinner').style.display = 'none';
    }

    // Helper function to convert a Blob to base64
    async function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const dataUrl = reader.result;
          const base64 = dataUrl.split(",")[1];
          resolve(base64);
        };
        reader.onerror = (err) => reject(err);
        reader.readAsDataURL(blob);
      });
    }

    // Renders plan steps with strike-out for completed steps
    function renderPlanSteps() {
      const planList = document.getElementById('planList');
      planList.innerHTML = '';

      planSteps.forEach((stepObj, idx) => {
        const li = document.createElement('li');
        li.textContent = stepObj.step_description || "No step description";
        if (idx < currentStepIndex) {
          li.classList.add('completed-step');
        }
        planList.appendChild(li);
      });
    }

    /**
     * Display history in #historyContent as a numbered list.
     * The backend returns an array of objects like:
     * [
     *   {
     *     "history_id": "history view 1",
     *     "description": "Some text..."
     *   }
     * ]
     */
    function updateHistoryDisplay(historyData) {
      const container = document.getElementById("historyContent");
      container.innerHTML = ""; // clear old content

      // If not an array or empty, show fallback
      if (!Array.isArray(historyData) || historyData.length === 0) {
        container.textContent = "No history yet.";
        return;
      }

      const ol = document.createElement("ol");
      historyData.forEach((entry) => {
        const li = document.createElement("li");
        li.textContent = entry.description || "No description available";
        ol.appendChild(li);
      });
      container.appendChild(ol);
    }

    // 1. Retrieve the plan from /get_plan, then generate (update) history
    document.getElementById('retrievePlanBtn').onclick = async () => {
      const goal = document.getElementById('goalInput').value.trim();
      if (!goal) {
        alert("Please enter a goal first.");
        return;
      }

      showSpinner(); // Show the loading spinner

      let base64Image = null;
      if (window.lastDroneBlob) {
        base64Image = await blobToBase64(window.lastDroneBlob);
      }

      // Build the request body for /get_plan
      const requestBodyForPlan = {
        goal: goal
      };
      if (globalHistory) {
        requestBodyForPlan.history = JSON.stringify(globalHistory);
      }
      if (planSteps.length > 0) {
        requestBodyForPlan.previousPlan = planSteps;
      }
      if (base64Image) {
        requestBodyForPlan.image = base64Image;
      }

      // 1A: Call /get_plan
      try {
        const responsePlan = await fetch('/get_plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBodyForPlan)
        });
        const dataPlan = await responsePlan.json();

        if (dataPlan.planSteps) {
          planSteps = dataPlan.planSteps;
          currentStepIndex = 0;
          renderPlanSteps();
        } else {
          console.warn("No planSteps in /get_plan response:", dataPlan);
        }
      } catch (err) {
        console.error("Error calling /get_plan:", err);
      }

      // 1B: Call /generate_history
      const requestBodyForHistory = {};
      if (globalHistory) {
        requestBodyForHistory.history = JSON.stringify(globalHistory);
      }
      if (base64Image) {
        requestBodyForHistory.image = base64Image;
      }

      try {
        const responseHist = await fetch('/generate_history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBodyForHistory)
        });

        const dataHist = await responseHist.json();
        // If the server directly returns an array
        if (Array.isArray(dataHist)) {
          globalHistory = dataHist;
          updateHistoryDisplay(globalHistory);
        } 
        // Otherwise, the server might return { updatedHistory: [...] }
        else if (Array.isArray(dataHist.updatedHistory)) {
          globalHistory = dataHist.updatedHistory;
          updateHistoryDisplay(globalHistory);
        } 
        else {
          console.warn("Unexpected /generate_history response:", dataHist);
        }
      } catch (err) {
        console.error("Error calling /generate_history:", err);
      } finally {
        hideSpinner(); // Hide the spinner once done
      }
    };

    // 2. Open the WebSocket
    document.getElementById('openWsBtn').onclick = () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.warn("WebSocket is already open.");
        return;
      }
      ws = new WebSocket("ws://localhost:8000/feed");

      ws.onopen = () => {
        console.log("WebSocket opened successfully.");
      };
      ws.onerror = (err) => {
        console.error("WebSocket Error:", err);
      };
      ws.onclose = () => {
        console.log("WebSocket closed.");
      };
      ws.onmessage = (event) => {
        console.log("WS Message:", event.data);
        try {
          const data = JSON.parse(event.data);

          // If there's a bounding_box
          if (data.bounding_box) {
            // We got a bounding box => hide spinner
            hideSpinner();  
            document.getElementById('bboxDisplay').textContent =
              `[${data.bounding_box.join(", ")}]`;
          }

          // If there's an updated history
          if (typeof data.history !== "undefined") {
            // If data.history is already an array
            if (Array.isArray(data.history)) {
              globalHistory = data.history;
              updateHistoryDisplay(globalHistory);
            } else {
              // Or if it's a string in JSON form
              try {
                const histObj = JSON.parse(data.history);
                if (Array.isArray(histObj)) {
                  globalHistory = histObj;
                  updateHistoryDisplay(histObj);
                } else {
                  console.warn("Unexpected history format from WS:", histObj);
                }
              } catch (e) {
                console.error("Error parsing WS history:", e);
              }
            }
          }

          // Updated step index?
          if (typeof data.currentStepIndex !== 'undefined') {
            currentStepIndex = data.currentStepIndex;
            renderPlanSteps();
          }
        } catch (e) {
          console.error("Error parsing WS message:", e);
        }
      };
    };

    // 3. Send the CURRENT step to the WS
    document.getElementById('sendStepBtn').onclick = () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket is not open.");
        return;
      }
      if (planSteps.length === 0) {
        alert("No plan steps to send. Retrieve a plan first.");
        return;
      }

      currentGoalText = planSteps[currentStepIndex]
        ? planSteps[currentStepIndex].step_description
        : "(No step found)";

      // Optionally show spinner if you like, then hide once a new WS message is received
      showSpinner();
      ws.send(JSON.stringify({ goal: currentGoalText }));
      console.log("Sent step as goal:", currentGoalText);
    };

    // 4. Send a frame (binary) to the WS, also call /generate_history
    document.getElementById('sendFrameBtn').onclick = async () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket is not open. Cannot send frame.");
        return;
      }
      if (!window.lastDroneBlob) {
        console.warn("No drone FPV frame available to send yet.");
        return;
      }

      showSpinner(); // Show spinner while we wait for bounding_box message

      // Send the binary data via WS
      const arrayBuffer = await window.lastDroneBlob.arrayBuffer();
      ws.send(arrayBuffer);
      console.log("Sent drone FPV frame to WebSocket.");

      // Update history with the same frame (via fetch)
      const base64Image = await blobToBase64(window.lastDroneBlob);
      const requestBodyForHistory = {};
      if (globalHistory) {
        requestBodyForHistory.history = JSON.stringify(globalHistory);
      }
      requestBodyForHistory.image = base64Image;

      try {
        const responseHist = await fetch('/generate_history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBodyForHistory)
        });
        const dataHist = await responseHist.json();

        if (Array.isArray(dataHist)) {
          globalHistory = dataHist;
          updateHistoryDisplay(globalHistory);
        } else if (Array.isArray(dataHist.updatedHistory)) {
          globalHistory = dataHist.updatedHistory;
          updateHistoryDisplay(globalHistory);
        } else {
          console.warn("Unexpected response from /generate_history:", dataHist);
        }
      } catch (err) {
        console.error("Error calling /generate_history:", err);
      }
      // Spinner will be hidden when we receive a bounding_box message from WS (onmessage handler)
      // or after a timeout if you want to auto-hide it anyway.
    };

    // 5. Complete the current step => increment step index
    document.getElementById('nextStepBtn').onclick = () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.warn("WebSocket is not open. Cannot complete step.");
        return;
      }
      // Optionally show a spinner until the step is completed
      showSpinner();
      ws.send(JSON.stringify({ completeStep: true }));
      console.log("Requested step completion.");
      // The spinner can be hidden in ws.onmessage when the step is actually completed, 
      // or you can hide it here if you prefer immediate feedback.
    };
  </script>
</body>
</html>
