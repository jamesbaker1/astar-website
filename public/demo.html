<!DOCTYPE html>
<html>
<head>
  <title>Monocular AI Drone</title>
  <style>
    body { 
      margin: 0; 
      background-color: #282C34;
      font-family: Arial, sans-serif; 
      color: #FFF; 
      position: relative;
      height: 100vh;
    }

    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      width: 200px;
    }
    #controls h2 {
      margin: 0 0 10px 0;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #controls p {
      margin: 5px 0;
      font-size: 14px;
    }
    #speed, #position, #camera-position {
      margin-top: 10px;
      font-size: 14px;
    }
    #pitch-info, #yaw-info, #roll-info {
      margin-top: 6px;
      font-size: 14px;
    }

    /* Main control panel on the left */
    #websocket-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #A40808;
    }
    #websocket-controls h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #websocket-controls button {
      width: 100%;
      padding: 6px;
      background: #A40808;
      border: none;
      border-radius: 3px;
      color: #FFF;
      cursor: pointer;
      font-weight: bold;
      margin-top: 5px;
    }
    #websocket-controls button:hover {
      background: #C51919;
    }
    #goalInput {
      width: 96%;
      padding: 6px;
      margin-top: 5px;
      border-radius: 3px;
      border: none;
    }
    #bboxDisplay {
      font-weight: bold;
      color: #FFD700;
    }

    /* Plan & Steps box */
    #plan-steps-container {
      position: absolute;
      bottom: 20px;
      right: 360px; 
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #048A17;
    }
    #plan-steps-container h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #planList {
      margin: 0;
      padding-left: 20px;
      font-size: 14px;
    }
    .completed-step {
      text-decoration: line-through;
      color: #AAA;
    }

    /* History box */
    #history-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      border: 2px dashed #808080;
    }
    #history-container h2 {
      margin: 0;
      margin-bottom: 10px;
      font-size: 16px;
      font-weight: bold;
      text-decoration: underline;
    }
    #historyContent {
      white-space: pre-wrap;
      max-height: 180px;
      overflow-y: auto;
      font-size: 14px;
      background-color: rgba(255,255,255,0.05);
      padding: 5px;
      border-radius: 5px;
    }

    /* Loading Spinner */
    #spinner {
      display: none; /* hidden by default */
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 9999;
      width: 64px;
      height: 64px;
      border: 8px solid rgba(255,255,255,0.2);
      border-top: 8px solid #FFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Hiding the "Complete Current Step" button for now */
    #nextStepBtn {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Spinner element (hidden by default) -->
  <div id="spinner"></div>

  <div id="controls">
    <h2>Controls</h2>
    <p>W/S: Increase/Decrease Throttle</p>
    <p>A/D: Yaw Left/Right</p>
    <p>I/K: Pitch Forward/Backward</p>
    <p>J/L: Roll Left/Right</p>
    <p>C: Toggle Drone (3rd person) View</p>
    <p>M: Toggle Bottom View</p>

    <p id="speed">Speed: 0</p>
    <p id="position">Position: (0, 0, 0)</p>
    <p id="camera-position">Camera Position: (0, 0, 0)</p>

    <p id="pitch-info">Pitch: 0</p>
    <p id="yaw-info">Yaw: 0</p>
    <p id="roll-info">Roll: 0</p>
  </div>

  <div id="websocket-controls">
    <h2>AI Pilot</h2>

    <!-- Retrieve plan from /get_plan -->
    <button id="retrievePlanBtn">Retrieve Plan</button>
    <label for="goalInput">Goal for Plan:</label>
    <input type="text" id="goalInput" value="Explore the city" />

    <!-- We'll send the current step as the "goal" in a JSON message (with optional frame) -->
    <button id="sendCurrentStepBtn">Send Current Step</button>

    <!-- Hidden for now (display: none) -->
    <button id="nextStepBtn">Complete Current Step</button>

    <p>Target: <span id="bboxDisplay">N/A</span></p>
  </div>

  <div id="plan-steps-container">
    <h2>Plan</h2>
    <ol id="planList"></ol>
  </div>

  <div id="history-container">
    <h2>History</h2>
    <div id="historyContent">No history yet.</div>
  </div>

  <!-- Drone-related scripts (assume your simulation code) -->
  <script src="https://threejs.org/build/three.js"></script>
  <script type="module" src="drone.js"></script>

  <script>
    // --------------------------------------------------------
    // GLOBALS FOR YAW CONTROL
    // --------------------------------------------------------
    // This holds the "remaining" yaw we need to turn
    window.yawNeeded = 0;  

    // This is our current absolute yaw in radians
    let yaw = 0;

    /**
     * Convert a bounding box in [0,1000] space to a yaw offset,
     * based on the actual image dimensions. 
     * Positive => turn left, negative => turn right.
     */
    function computeYawNeeded(bbox, imageWidth, imageHeight) {
      // bbox is [ymin, xmin, ymax, xmax] in [0,1000] range
      const [ymin, xmin, ymax, xmax] = bbox;

      // 1. Find bounding box center in X (scaled to imageWidth)
      const centerX = ((xmin + xmax) / 2 / 1000) * imageWidth;

      // 2. How far from the image's horizontal center (in px)
      const offsetX = centerX - imageWidth / 2;

      // 3. Normalize to [-1,1] (left edge ~ -1, right edge ~ +1)
      const normalizedOffset = offsetX / (imageWidth / 2);

      // 4. Scale by desired maximum yaw, e.g. ±π
      const maxYaw = Math.PI / 2;  // 180 degrees
      const yawNeeded = normalizedOffset * maxYaw;

      return yawNeeded;
    }

    // --------------------------------------------------------
    // WEBSOCKET AND UI LOGIC
    // --------------------------------------------------------
    let ws = null;
    let planSteps = [];
    let currentStepIndex = 0;
    let globalHistory = []; // array of strings
    let currentGoalText = "";

    // Open WebSocket as soon as the page loads:
    window.addEventListener("load", () => {
      ws = new WebSocket("ws://localhost:8000/feed");

      ws.onopen = () => {
        console.log("WebSocket opened successfully (page load).");
      };

      ws.onerror = (err) => {
        console.error("WebSocket Error:", err);
      };

      ws.onclose = () => {
        console.log("WebSocket closed.");
      };

      ws.onmessage = (event) => {
        console.log("WS Message:", event.data);
        try {
          const parsed = JSON.parse(event.data);
          switch (parsed.type) {
            case "bounding_box":
              // Hide spinner when bounding_box arrives
              hideSpinner();

              // Show the bounding box in UI
              document.getElementById('bboxDisplay').textContent =
                `[${parsed.data.join(", ")}]`;
              
              // Now compute how much yaw is needed to turn toward that bbox center
              // For example, assume our "video feed" is 1280 wide x 720 high:
              window.yawNeeded = computeYawNeeded(parsed.data, 320, 240);

              console.log("New bounding box:", parsed.data);
              console.log("Computed yawNeeded:", window.yawNeeded);
              break;

            case "history":
              // Update local history array
              globalHistory = parsed.data;
              updateHistoryDisplay(globalHistory);
              break;

            case "error":
              // The server might send an "error" type
              hideSpinner();
              console.error("Server error:", parsed.message);
              alert("Server error: " + parsed.message);
              break;

            default:
              console.log("Unrecognized WS message type:", parsed.type);
              break;
          }
        } catch (e) {
          console.error("Error parsing WS message:", e);
        }
      };
    });

    // Helper function to show/hide the spinner
    function showSpinner() {
      document.getElementById('spinner').style.display = 'block';
    }
    function hideSpinner() {
      document.getElementById('spinner').style.display = 'none';
    }

    // Helper function to convert a Blob to base64
    async function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const dataUrl = reader.result;
          const base64 = dataUrl.split(",")[1];
          resolve(base64);
        };
        reader.onerror = (err) => reject(err);
        reader.readAsDataURL(blob);
      });
    }

    // Render plan steps with strike-out for completed steps
    function renderPlanSteps() {
      const planList = document.getElementById('planList');
      planList.innerHTML = '';

      planSteps.forEach((stepObj, idx) => {
        const li = document.createElement('li');
        li.textContent = stepObj.step_description || "No step description";
        if (idx < currentStepIndex) {
          li.classList.add('completed-step');
        }
        planList.appendChild(li);
      });
    }

    /**
     * Display history in #historyContent as a numbered list of vantage strings.
     */
    function updateHistoryDisplay(historyData) {
      const container = document.getElementById("historyContent");
      container.innerHTML = ""; // clear old content

      if (!Array.isArray(historyData) || historyData.length === 0) {
        container.textContent = "No history yet.";
        return;
      }

      const ol = document.createElement("ol");
      historyData.forEach((entry) => {
        const li = document.createElement("li");
        // Each "entry" is just a string now
        li.textContent = entry;
        ol.appendChild(li);
      });
      container.appendChild(ol);
    }

    // 1. Retrieve the plan from /get_plan
    document.getElementById('retrievePlanBtn').onclick = async () => {
      const goal = document.getElementById('goalInput').value.trim();
      if (!goal) {
        alert("Please enter a goal first.");
        return;
      }

      showSpinner(); // Show the loading spinner

      let base64Image = null;
      if (window.lastDroneBlob) {
        base64Image = await blobToBase64(window.lastDroneBlob);
      }

      // Build the request body for /get_plan
      const requestBodyForPlan = {
        goal: goal
      };
      // Optionally add re-eval context
      if (globalHistory && globalHistory.length > 0) {
        requestBodyForPlan.history = globalHistory;
      }
      if (planSteps.length > 0) {
        requestBodyForPlan.previousPlan = planSteps;
      }
      if (base64Image) {
        requestBodyForPlan.image = base64Image;
      }

      try {
        const responsePlan = await fetch('/get_plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBodyForPlan)
        });
        const dataPlan = await responsePlan.json();

        if (dataPlan.planSteps) {
          planSteps = dataPlan.planSteps;
          currentStepIndex = 0;
          renderPlanSteps();
        } else {
          console.warn("No planSteps in /get_plan response:", dataPlan);
        }
      } catch (err) {
        console.error("Error calling /get_plan:", err);
      } finally {
        hideSpinner();
      }
    };

    // 2. Send the CURRENT step (now that WebSocket opens on page load)
    document.getElementById('sendCurrentStepBtn').onclick = async () => {
      if (planSteps.length === 0) {
        alert("No plan steps to send. Retrieve a plan first.");
        return;
      }

      // If the socket isn't open yet (or closed), let's bail out
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert("WebSocket is not open yet, please wait and try again.");
        return;
      }

      // The current step's "goal" text
      currentGoalText = planSteps[currentStepIndex]
        ? planSteps[currentStepIndex].step_description
        : "(No step found)";

      // Optionally attach the current frame
      let base64Image = null;
      if (window.lastDroneBlob) {
        base64Image = await blobToBase64(window.lastDroneBlob);
      }

      showSpinner();
      // Send a JSON message with {goal, history, image}
      ws.send(JSON.stringify({
        goal: currentGoalText,
        history: globalHistory || [],
        image: base64Image
      }));

      console.log("Sent step as goal + optional image to WS:", currentGoalText);
      console.log("History: ", globalHistory || []);

      // Automatically increment the step once the previous step is sent
      if (currentStepIndex < planSteps.length) {
        currentStepIndex += 1;
        renderPlanSteps();
      }
    };
  </script>
</body>
</html>
